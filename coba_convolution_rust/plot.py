#!/usr/bin/env python3
"""
Signal Data Plotter - Visualizes time-domain convolution results
Reads CSV data generated by the Rust convolution demo and creates plots.
Uses only standard library + numpy (no pandas dependency).
"""

import csv
import matplotlib.pyplot as plt
import numpy as np
import sys
import os


def load_signal_data(filename):
    """Load signal data from CSV file using standard library."""
    try:
        with open(filename, "r") as file:
            reader = csv.DictReader(file)
            data = {"index": [], "time": [], "input": [], "output": []}

            for row in reader:
                data["index"].append(int(row["index"]))
                data["time"].append(float(row["time"]))
                data["input"].append(float(row["input"]))
                data["output"].append(float(row["output"]))

        # Convert to numpy arrays
        for key in data:
            data[key] = np.array(data[key])

        print(f"Loaded {len(data['index'])} samples from {filename}")
        return data

    except FileNotFoundError:
        print(f"Error: File '{filename}' not found.")
        print("Please run the Rust program first to generate signal_data.csv")
        return None
    except Exception as e:
        print(f"Error loading file: {e}")
        return None


def plot_signals(data, save_plots=True):
    """Create comprehensive plots of the signal data."""

    # Create figure with subplots
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
    fig.suptitle("Time-Domain FIR Filter Analysis", fontsize=16)

    # Extract data
    time = data["time"]
    input_signal = data["input"]
    output_signal = data["output"]
    indices = data["index"]

    # 1. Full time-domain view (top-left)
    ax1.plot(time, input_signal, "b-", linewidth=1.5, label="Input Signal", alpha=0.8)
    ax1.plot(
        time, output_signal, "r-", linewidth=1.5, label="Filtered Output", alpha=0.8
    )
    ax1.set_xlabel("Time (s)")
    ax1.set_ylabel("Amplitude")
    ax1.set_title("Complete Signal View")
    ax1.grid(True, alpha=0.3)
    ax1.legend()

    # 2. Zoomed view - first 100 samples (top-right)
    zoom_samples = min(100, len(time))
    ax2.plot(
        time[:zoom_samples],
        input_signal[:zoom_samples],
        "b-",
        linewidth=2,
        label="Input Signal",
        marker="o",
        markersize=3,
    )
    ax2.plot(
        time[:zoom_samples],
        output_signal[:zoom_samples],
        "r-",
        linewidth=2,
        label="Filtered Output",
        marker="s",
        markersize=2,
    )
    ax2.set_xlabel("Time (s)")
    ax2.set_ylabel("Amplitude")
    ax2.set_title(f"Zoomed View - First {zoom_samples} Samples")
    ax2.grid(True, alpha=0.3)
    ax2.legend()

    # 3. Filter settling behavior (bottom-left)
    # Show first few samples to see filter warm-up
    settling_samples = min(50, len(time))
    ax3.plot(
        indices[:settling_samples],
        input_signal[:settling_samples],
        "b-",
        linewidth=2,
        label="Input Signal",
        marker="o",
        markersize=4,
    )
    ax3.plot(
        indices[:settling_samples],
        output_signal[:settling_samples],
        "r-",
        linewidth=2,
        label="Filtered Output",
        marker="s",
        markersize=3,
    )
    ax3.set_xlabel("Sample Index")
    ax3.set_ylabel("Amplitude")
    ax3.set_title("Filter Settling Behavior")
    ax3.grid(True, alpha=0.3)
    ax3.legend()

    # 4. Frequency analysis (bottom-right)
    # Simple FFT magnitude plot
    N = len(input_signal)
    fft_input = np.fft.fft(input_signal)
    fft_output = np.fft.fft(output_signal)
    frequencies = np.fft.fftfreq(N, d=time[1] - time[0])

    # Only plot positive frequencies
    positive_freqs = frequencies[: N // 2]
    input_magnitude = np.abs(fft_input[: N // 2])
    output_magnitude = np.abs(fft_output[: N // 2])

    ax4.plot(
        positive_freqs,
        20 * np.log10(input_magnitude + 1e-10),
        "b-",
        linewidth=2,
        label="Input Spectrum",
    )
    ax4.plot(
        positive_freqs,
        20 * np.log10(output_magnitude + 1e-10),
        "r-",
        linewidth=2,
        label="Output Spectrum",
    )
    ax4.set_xlabel("Frequency (Hz)")
    ax4.set_ylabel("Magnitude (dB)")
    ax4.set_title("Frequency Domain Analysis")
    ax4.grid(True, alpha=0.3)
    ax4.legend()
    ax4.set_xlim(0, min(500, positive_freqs[-1]))  # Limit to relevant range

    plt.tight_layout()

    if save_plots:
        plt.savefig("signal_analysis.png", dpi=300, bbox_inches="tight")
        print("Plot saved as: signal_analysis.png")

    plt.show()


def print_statistics(data):
    """Print basic statistics about the signals."""
    input_signal = data["input"]
    output_signal = data["output"]
    time = data["time"]

    print("\n" + "=" * 50)
    print("SIGNAL STATISTICS")
    print("=" * 50)

    # Basic statistics
    print(f"Number of samples: {len(data['index'])}")
    print(f"Total duration: {time[-1]:.3f} seconds")
    print(f"Sampling rate: {1/(time[1] - time[0]):.1f} Hz")

    print("\nInput Signal:")
    print(f"  RMS: {np.sqrt(np.mean(input_signal**2)):.4f}")
    print(f"  Peak: {np.max(np.abs(input_signal)):.4f}")
    print(f"  Mean: {np.mean(input_signal):.6f}")

    print("\nOutput Signal:")
    print(f"  RMS: {np.sqrt(np.mean(output_signal**2)):.4f}")
    print(f"  Peak: {np.max(np.abs(output_signal)):.4f}")
    print(f"  Mean: {np.mean(output_signal):.6f}")

    # Filter effect
    input_rms = np.sqrt(np.mean(input_signal**2))
    output_rms = np.sqrt(np.mean(output_signal**2))
    attenuation_db = 20 * np.log10(output_rms / input_rms)

    print(f"\nFilter Effect:")
    print(f"  Attenuation: {attenuation_db:.2f} dB")
    print(f"  Gain ratio: {output_rms/input_rms:.4f}")


def main():
    """Main function to load data and create plots."""
    # Default filename
    filename = "signal_data.csv"

    # Check if custom filename provided
    if len(sys.argv) > 1:
        filename = sys.argv[1]

    # Check if file exists
    if not os.path.exists(filename):
        print(f"File '{filename}' not found.")
        print("Please run the Rust program first to generate the CSV file.")
        return

    # Load and process data
    data = load_signal_data(filename)
    if data is None:
        return

    # Print statistics
    print_statistics(data)

    # Create plots
    plot_signals(data, save_plots=True)

    print("\nAnalysis complete!")


if __name__ == "__main__":
    main()
